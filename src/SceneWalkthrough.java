/**
 * SceneWalkthrough by Anton Ridgway
 * December 3, 2014
 * 
 * Visualizes a scene from GridFloat terrain data, and provides a minimal user interface
 * to interact with it. Lights and materials are applied to the scene, with the light and sky
 * color varying to simulate the time of day. A small flag is also placed at the highest point
 * in the terrain.
 * 
 * The user can use the arrow keys and mouse to walk through the scene and change the viewpoint,
 * respectively, while the right mouse button allows for crouching, and the space bar for a small
 * jump. The left mouse button also fires a small flare in the direction of the camera, and the
 * mouse wheel zooms the display.
 * 
 * Parameters have been tuned to a realistic(-ish) scale, where the user is assumed
 * to be 2m tall, with a walking speed of 1.34 m/s and a jump height of 1m. However, a menu is also
 * provided that allows for conveniences needed to inspect the scene, such as flight and increased
 * movement speed.
 * 
 * A texture is also applied to the terrain. A supplied texture (with the same name as the GridFloat 
 * files to be read, but .png format) can be used, as well as the .jpg thumbnail sometimes provided
 * with GridFloat data, and a default grass image.
 */

import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.GLProfile;
import javax.media.opengl.GLCapabilities;
import javax.media.opengl.awt.GLJPanel;
import javax.media.opengl.glu.GLU;
import javax.swing.AbstractAction;
import javax.swing.InputMap;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JRootPane;
import javax.swing.KeyStroke;
import javax.swing.UIManager;

import com.jogamp.opengl.util.FPSAnimator;
import com.jogamp.opengl.util.texture.Texture;
import com.jogamp.opengl.util.texture.TextureData;
import com.jogamp.opengl.util.texture.TextureIO;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.security.CodeSource;
import java.util.ArrayList;
import java.util.Iterator;

public class SceneWalkthrough extends JFrame implements GLEventListener, MouseListener, MouseMotionListener, MouseWheelListener
{
	//Generated by Eclipse
	private static final long serialVersionUID = 5339346592230176731L;
	
	//Default Constants
	private static final int DEFAULT_WIDTH = 800;
	private static final int DEFAULT_HEIGHT = 600;
	private static final int TARGET_FPS = 60;
	
	//Camera Initial Constants
	private static final double DEFAULT_FOV = 140.0; //in degrees
	private static final double DEFAULT_AR = (int)(((double)DEFAULT_WIDTH)/DEFAULT_HEIGHT);
	private static final double DEFAULT_ZNEAR = 0.00001;
	private static final double DEFAULT_ZFAR = 10;
	private static final double[] DEFAULT_POS = new double[]{0,0,5};
	private static final double[] DEFAULT_DIR = new double[]{1,0,0};
	private static final double[] DEFAULT_UP = new double[]{0,0,1};
	private static final double FOV_INCREMENT = 3.0;
	private static final double FOV_MIN = 10.0;
	private static final double FOV_MAX = 160.0;
	
	//User Movement Constraints
	private static final double ROTATION_SPEED_X = Math.PI/40.;
	private static final double ROTATION_RANGE_Y = Math.PI/3.;
	private static final double USER_HEIGHT = 2.0; //in meters
	private static final double USER_CROUCH_HEIGHT = 1.0; //in meters
	private static final double USER_WALK_SPEED = 1.34; //in meters per second
	private static final double USER_WALK_SPEED_MULTIPLIER = 1.0;
	private static final double USER_JUMP_HEIGHT = 1.0; //in meters
	private static final double WORLD_GRAVITY = 9.81; //m/s^2
	
	//Conversion Constants
	private static final double NS_TO_SECONDS = 1./1000000000.;
	private static final double SECONDS_TO_HOURS = 1./60./60.;
	
	//Time Constants
	private static final double TIME_START = 8.;
	private static final int TIME_HOURS_PER_DAY = 24;
	private static final double TIME_SPEED_MULTIPLIER = 600.; //24 hours -> 2.4 minutes
	private static final double TIME_SUNRISE_START = 6.5;
	private static final double TIME_SUNRISE_END = 8.;
	private static final double TIME_SUNRISE_MID = (TIME_SUNRISE_START+TIME_SUNRISE_END)/2.;
	private static final double TIME_SUNSET_START = 19.5;
	private static final double TIME_SUNSET_END = 21.;
	private static final double TIME_SUNSET_MID = (TIME_SUNSET_START+TIME_SUNSET_END)/2.;
	private static final float[] TIME_COLOR_NIGHT = new float[]{0.031373f, 0.031373f, 0.1254902f};
	private static final float[] TIME_COLOR_SUNRISE = new float[]{0.913725f, 0.533333f, 0.396078f};
	private static final float[] TIME_COLOR_DAY = new float[]{0.274510f, 0.545098f, 0.847059f};
	private static final float[] TIME_COLOR_SUNSET = new float[]{0.780392f, 0.439216f, 0.160784f};
	private static final double LIGHT_START_ANGLE = 2.0*Math.PI;
	private static final double LIGHT_END_ANGLE = 1.0*Math.PI;
	
	//Main Light Information
	private static final float[] DAY_LIGHT_AMBIENT = new float[]{0.01f, 0.01f, 0.01f, 1.0f};
	private static final float[] DAY_LIGHT_DIFFUSE = new float[]{0.7f, 0.7f, 0.7f, 1.0f};
	private static final float[] DAY_LIGHT_SPECULAR = new float[]{0.5f, 0.5f, 0.5f, 1.0f};
	private static final float[] NIGHT_LIGHT_AMBIENT = new float[]{0.001f, 0.001f, 0.001f, 1.0f};
	private static final float[] NIGHT_LIGHT_DIFFUSE = new float[]{0.1f, 0.1f, 0.1f, 1.0f};
	private static final float[] NIGHT_LIGHT_SPECULAR = new float[]{0.1f, 0.1f, 0.1f, 1.0f};
	private static final float[] NO_LIGHT = new float[]{0.0f, 0.0f, 0.0f, 1.0f};
	private static final float[] INIT_LIGHT_POSITION = new float[]{1.0f, 2.0f, -3.0f, 0.0f};
	private static final float[] BACKGROUND_COLOR = TIME_COLOR_DAY;
	
	//UI Initial Constants
	private static final boolean DEFAULT_SHOW_MARKER_VALUE = true;
	private static final boolean DEFAULT_SHOW_WIREFRAME_VALUE = false;
	private static final boolean DEFAULT_FLY_MODE_VALUE = false;
	private static final double GRID_SCALE = 1.; //Directly related to the value of Z_NEAR, to prevent clipping too far from the camera.
	
	//Terrain Display Information
	private static String currentDatafile = "";
	private static boolean showMarker = DEFAULT_SHOW_MARKER_VALUE;
	private static boolean showWireframe = DEFAULT_SHOW_WIREFRAME_VALUE;
	private static GridFloatReader gridData;
	private static double gridWidth, gridHeight, unitsPerMeter,
						  cellSizeX, cellSizeY;
	private static final float[] GRID_MAT_AMBIENT = new float[]{1.0f, 1.0f, 1.0f, 1.0f};
	private static final float[] GRID_MAT_DIFFUSE = new float[]{1.0f, 1.0f, 1.0f, 1.0f};
	private static final float[] GRID_MAT_SPECULAR = new float[]{1.0f, 1.0f, 1.0f, 1.0f};
	private static final float GRID_MAT_SHININESS = 6.0f;
	private float[] gridAmbient = GRID_MAT_AMBIENT;
	private float[] gridDiffuse = GRID_MAT_DIFFUSE;
	private float[] gridSpecular = GRID_MAT_SPECULAR;
	private float gridShininess = GRID_MAT_SHININESS;
	private static Texture gridTexture;
	
	//Marker Display Information
	private static final double MARKER_SIDE_LENGTH = 5.0; //in meters
	private static final String MARKER_TEXTURE = "flag.png";
	private float[] markerAmbient = GRID_MAT_AMBIENT;
	private float[] markerDiffuse = GRID_MAT_DIFFUSE;
	private float[] markerSpecular = GRID_MAT_SPECULAR;
	private float markerShininess = GRID_MAT_SHININESS;
	private static Texture markerTexture;

	//Projectile Display Information
	/*
	 * Projectile arrays have the following format:
	 * Three values for x-y-z position
	 * Three values for x-y-z speed, in world units per second
	 * One value for lifetime remaining
	 */
	private static final String PROJECTILE_TEXTURE = "flare.png";
	private static final float[] P_LIGHT_AMBIENT = new float[]{0.0f, 0.0f, 0.0f, 1.0f};
	private static final float[] P_LIGHT_DIFFUSE = new float[]{1.0f, 0.0f, 0.0f, 1.0f};
	private static final float[] P_LIGHT_SPECULAR = new float[]{1.0f, 0.3f, 0.3f, 1.0f};
	private static final float[] P_MAT_AMBIENT = new float[]{1.0f, 1.0f, 1.0f, 1.0f};
	private static final float[] P_MAT_DIFFUSE = new float[]{1.0f, 1.0f, 1.0f, 1.0f};
	private static final float[] P_MAT_SPECULAR = new float[]{1.0f, 1.0f, 1.0f, 1.0f};
	private static final float P_MAT_SHININESS = 0.0f;	
	private static final double PROJECTILE_SIDE_LENGTH = 0.8;
	private static final double PROJECTILE_LIFETIME = 3.0; //in seconds
	private static final double PROJECTILE_SPEED = 80.0; //in m/s, the muzzle velocity of a flare gun
	private static final int MAX_NUM_PROJECTILES = 3;
	private static ArrayList<double[]> projectiles = new ArrayList<double[]>();
	private static Texture projectileTexture;
	private static int numFlareLights = 0;
	
	//Display List IDs 
	private boolean listNumsGenerated = false;
	private boolean meshGenerated = false;
	private int meshList, markerList;
	
	//OpenGL Display and Interaction Entities
	private GL2 gl2;
	private GLProfile myProfile = null;
	private GLCapabilities myCapabilities = null;
	private GLJPanel myCanvas = null;
	private int canvasWidth, canvasHeight, canvasCenterX, canvasCenterY;
	private float[] backgroundColor = BACKGROUND_COLOR;
	private FPSAnimator myAnimator;
	private double mouseX, mouseY;
	private boolean rMouseDown, wDown, aDown, sDown, dDown, spaceDown;
	private int wheelMoves = 0;

	//Camera Properties
	private GLU glu;
	private double camFOV = DEFAULT_FOV;
	private double camAspectRatio = DEFAULT_AR;
	private double camZNear = DEFAULT_ZNEAR;
	private double camZFar = DEFAULT_ZFAR;
	private double[] camPos = DEFAULT_POS;
	private double[] camDir = DEFAULT_DIR;
	private double[] camUp = DEFAULT_UP;
	private double speedMultiplier = USER_WALK_SPEED_MULTIPLIER;
	private boolean flyMode = DEFAULT_FLY_MODE_VALUE;
	private double camVelocity = 0;
	private boolean jumping = false;
	private long currentTime = 0L;
	private double updateTime = 0;
	private double timeOfDay = TIME_START;
	
	//UI Components
	private File appFilePath;
	private JMenuBar topMenuBar;
	private JMenu topMenu;
	private JMenuItem openFileButton;
	private JMenuItem speedButton;
	private JMenuItem resetButton;
	private JMenuItem quitButton;
	private JCheckBoxMenuItem flyCheckbox;
	private JCheckBoxMenuItem markerCheckbox;
	private JCheckBoxMenuItem wireframeCheckbox;
	
	public SceneWalkthrough()
	{
		//Initialize the frame and create the canvas.
		super("Anton Ridgway - Scene Walkthrough");
        myProfile = GLProfile.getDefault();
        myCapabilities = new GLCapabilities( myProfile );
        myCanvas = new GLJPanel( myCapabilities );
        myCanvas.addGLEventListener(this);
        myCanvas.addMouseListener(this);
        myCanvas.addMouseMotionListener(this);
        myCanvas.addMouseWheelListener(this);
        myAnimator = new FPSAnimator(myCanvas, TARGET_FPS);
        myAnimator.start();
        currentTime = System.nanoTime();
        
        //Add a window listener to close the window when needed.
        addWindowListener(
        	new WindowAdapter()
        	{
	            public void windowClosing( WindowEvent windowevent )
	            {
	                remove(myCanvas);
	                dispose();
	                System.exit(0);
	            }
            }
    	);
	    
        setKeyBindings();
        buildGUI();
        setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
        setVisible( true );
	}
	
	/**
	 * setKeyBindings sets key bindings for the JFrame's root pane.  This is used instead of
	 * Key Listeners to prevent unwanted components in focus from consuming the events.
	 */
	private void setKeyBindings()
	{
		InputMap inputMap = getRootPane().getInputMap(JRootPane.WHEN_IN_FOCUSED_WINDOW);
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_W, 0, false), "wDown");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_W, 0, true), "wUp");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, 0, false), "aDown");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, 0, true), "aUp");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_S, 0, false), "sDown");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_S, 0, true), "sUp");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_D, 0, false), "dDown");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_D, 0, true), "dUp");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0, false), "spaceDown");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0, true), "spaceUp");
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_R, 0, true), "rDown");
		getRootPane().getActionMap().put("wDown", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	wDown = true; }
		});
		getRootPane().getActionMap().put("wUp", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	wDown = false; }
		});
		getRootPane().getActionMap().put("aDown", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	aDown = true; }
		});
		getRootPane().getActionMap().put("aUp", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	aDown = false; }
		});
		getRootPane().getActionMap().put("sDown", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	sDown = true; }
		});
		getRootPane().getActionMap().put("sUp", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	sDown = false; }
		});
		getRootPane().getActionMap().put("dDown", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	dDown = true; }
		});
		getRootPane().getActionMap().put("dUp", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	dDown = false; }
		});
		getRootPane().getActionMap().put("spaceDown", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	spaceDown = true; }
		});
		getRootPane().getActionMap().put("spaceUp", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	spaceDown = false; }
		});
		getRootPane().getActionMap().put("rDown", new AbstractAction(){
			public void actionPerformed(ActionEvent arg0) {	handleReset(); }
		});
	}
	
	/**
	 * buildGUI handles GUI initialization and adds all components to the main frame.
	 */
	private void buildGUI()
	{
		//Set natural look and feel.
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		this.add(myCanvas);
		
		topMenuBar = new JMenuBar();
		topMenu = new JMenu("Options");
		topMenu.setMnemonic(KeyEvent.VK_O);
		openFileButton = new JMenuItem("Open File...");
		markerCheckbox = new JCheckBoxMenuItem("Show marker",true);
		wireframeCheckbox = new JCheckBoxMenuItem("Show wireframe",false);
		flyCheckbox = new JCheckBoxMenuItem("Allow flying",false);
		speedButton = new JMenuItem("Adjust speed...");
		resetButton = new JMenuItem("Reset");
		quitButton = new JMenuItem("Quit");
		
		this.setJMenuBar(topMenuBar);
		topMenuBar.add(topMenu);
		topMenu.add(openFileButton);
		topMenu.addSeparator();
		topMenu.add(markerCheckbox);
		topMenu.add(wireframeCheckbox);
		topMenu.add(flyCheckbox);
		topMenu.add(speedButton);
		topMenu.add(resetButton);
		topMenu.addSeparator();
		topMenu.add(quitButton);

		//Set up the file path for the open file dialog.
		try {
			CodeSource source = TerrainVis.class.getProtectionDomain().getCodeSource();
			if(source != null)
			{
				String binDirectory = source.getLocation().toURI().getPath();
				appFilePath = new File(binDirectory).getParentFile();
			}
			else
				appFilePath = null;
		} catch(URISyntaxException e) {
			e.printStackTrace();
		}
		
		//Set up individual components with appropriate listeners.
		openFileButton.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				handleLoadFile();
			}
		});
		markerCheckbox.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				showMarker = !showMarker;
			}
		});
		markerCheckbox.setEnabled(false);
		wireframeCheckbox.addActionListener(new ActionListener(){
			@Override
			public void actionPerformed(ActionEvent arg0) {
				showWireframe = !showWireframe;
			}
		});
		wireframeCheckbox.setEnabled(false);
		flyCheckbox.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				flyMode = !flyMode;
				camVelocity = 0;
				jumping = false;
			}
		});
		flyCheckbox.setEnabled(false);
		speedButton.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				handleAdjustSpeed();
			}
		});
		speedButton.setEnabled(false);
		resetButton.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				handleReset();
			}
		});
		resetButton.setEnabled(false);
		quitButton.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				handleQuit();
			}
		});
	}
	
	/**
	 * handleLoadFile prompts the user to choose a file, uses gridFloatReader to read in the
	 * file information, and processes it.
	 */
	private void handleLoadFile()
	{
		JFileChooser openFileDialog = new JFileChooser(appFilePath);
		int returnVal = openFileDialog.showOpenDialog(this);
		if(returnVal == JFileChooser.APPROVE_OPTION)
		{
			File newFile = openFileDialog.getSelectedFile();
			String newDataFile = newFile.getPath();
			int dotPosition = newDataFile.lastIndexOf('.');
			if(dotPosition >= -1) newDataFile = newDataFile.substring(0,dotPosition);
			
			//If the same file is chosen, do nothing.
			if(!newDataFile.equals(currentDatafile))
			{
				currentDatafile = newDataFile;
				gridData = new GridFloatReader(currentDatafile);

		    	unitsPerMeter = (GRID_SCALE/gridData.numRows)/gridData.cellSizeY;
		    	cellSizeY = unitsPerMeter*gridData.cellSizeY;
		    	cellSizeX = unitsPerMeter*gridData.cellSizeX;
			    gridWidth = (gridData.numColumns-1)*cellSizeX;
			    gridHeight = (gridData.numRows-1)*cellSizeY;
			    
		        //Enable UI buttons
				markerCheckbox.setEnabled(true);
				wireframeCheckbox.setEnabled(true);
				flyCheckbox.setEnabled(true);
				speedButton.setEnabled(true);
				resetButton.setEnabled(true);
				
				//Notify the GL context to generate the display lists.
				meshGenerated = false;
			}
   		}
	}
	
	/**
	 * handleAdjustSpeed prompts the user to enter a new speed multiplier for walking speed.
	 */
	private void handleAdjustSpeed()
	{
		String newSpeed = (String)JOptionPane.showInputDialog(
							this,
							"Choose a speed multiplier:",
							"Adjust Speed",
							JOptionPane.PLAIN_MESSAGE);
		try
		{
			speedMultiplier = Double.parseDouble(newSpeed);
		} catch(Exception e) {
			speedMultiplier = USER_WALK_SPEED_MULTIPLIER;
		}
	}
	
	/**
	 * Resets the camera configuration to initial settings.
	 */
	private void handleReset()
	{
		camPos = DEFAULT_POS;
		camDir = DEFAULT_DIR;
		camFOV = DEFAULT_FOV;
		markerCheckbox.setSelected(DEFAULT_SHOW_MARKER_VALUE);
		showMarker = DEFAULT_SHOW_MARKER_VALUE;
		wireframeCheckbox.setSelected(DEFAULT_SHOW_WIREFRAME_VALUE);
		showWireframe = DEFAULT_SHOW_WIREFRAME_VALUE;
		flyCheckbox.setSelected(DEFAULT_FLY_MODE_VALUE);
		flyMode = DEFAULT_FLY_MODE_VALUE;
		speedMultiplier = USER_WALK_SPEED_MULTIPLIER;
		camVelocity = 0;
	}
	
	/**
	 * Closes the program.
	 */
	private void handleQuit()
	{
		System.exit(0);
	}
	
	/**
	 * Handles a left click by the user, creating projectiles if needed.
	 */
	private void handleLeftClick()
	{
		double adjustedSpeed = PROJECTILE_SPEED*unitsPerMeter;
		if(projectiles.size() < MAX_NUM_PROJECTILES)
		{
			projectiles.add(new double[]{camPos[0], camPos[1], camPos[2]+getUserHeight(),
										 camDir[0]*adjustedSpeed, camDir[1]*adjustedSpeed, camDir[2]*adjustedSpeed,
										 PROJECTILE_LIFETIME});
		}
	}

	/**
	 * A wrapper method which stores terrain and marker display commands in a display list instead
	 * of executing them immediately. meshGenerated should not be true.
	 */
	private void generateMeshes()
	{
		assert(!meshGenerated);
		
		//Load map texture.
		try { //Look for a provided texture.
			File filename = new File(currentDatafile+".png"); 
			boolean isJpg = false;
			if(!filename.exists()) { //Look for the USGS thumbnail for a texture.
				filename = new File(currentDatafile+"_thumb.jpg");
				if(!filename.exists()) { //Look for the default grass texture in the local directory.
					filename = new File("grass.png");
					if(!filename.exists()) { //Look for the default grass texture in the project root directory.
						filename = new File(appFilePath+File.separator+"grass.png");
					}
				}
				else isJpg = true; //If JPG thumbnail found
			}
			if(filename.exists())
			{
				InputStream stream = new FileInputStream(filename);
				TextureData data = TextureIO.newTextureData(myProfile, stream, false, isJpg ? "jpg" : "png");
				gridTexture = TextureIO.newTexture(data);
				stream.close();
			}
			else
				gridTexture = null;
		} catch (IOException e) {
			e.printStackTrace();
			gridTexture = null;
		}
		
        gl2.glNewList(meshList, GL2.GL_COMPILE);
        drawTerrain();
        gl2.glEndList();
        gl2.glNewList(markerList, GL2.GL_COMPILE);
        drawMarker();
        gl2.glEndList();
	}

	/**
	 * drawTerrain loops across each of the cells for which we have data, and draws a
	 * triangle strip for each column.  It calls getVertexNormal to get the normal for
	 * each point, and defines texture coordinates for each.
	 */
	private void drawTerrain()
	{
		if(gridData == null) return;
		
		if(gridTexture != null)
		{
			gridTexture.enable(gl2);
			gridTexture.bind(gl2);
		}
		
		//Set the material properties for the mesh
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_AMBIENT, FloatBuffer.wrap(gridAmbient));
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_DIFFUSE, FloatBuffer.wrap(gridDiffuse));
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_SPECULAR, FloatBuffer.wrap(gridSpecular));
		gl2.glMaterialf(GL2.GL_FRONT, GL2.GL_SHININESS, gridShininess);
		
		//Offsets for the grid, to center it.
		double gridX = -gridWidth/2;
		double gridY = -gridHeight/2;
		
		//Iterate through cells bottom-to-top, left-to-right
		//Get the lower-left-hand corner of each as cellX, cellY
		for(int x = 0; x < gridData.numColumns-2; x++)
		{
			double cellX = gridX + x*cellSizeX;
			gl2.glBegin(GL.GL_TRIANGLE_STRIP);
			for(int y = 0; y < gridData.numRows; y++)
			{
				double cellY = gridY+(gridData.numRows-1-y)*cellSizeY;
				
				double[] vNormal = getVertexNormal(x,y);
				gl2.glNormal3d(vNormal[0], vNormal[1], vNormal[2]);
				gl2.glTexCoord2d(((double)x)/(gridData.numColumns-1.), ((double)(gridData.numRows-y))/(gridData.numRows-1.));
				gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{cellX, cellY, unitsPerMeter*(gridData.height[y][x]-gridData.avgHeight)}));
				
				vNormal = getVertexNormal(x+1,y);
				gl2.glNormal3d(vNormal[0], vNormal[1], vNormal[2]);
				gl2.glTexCoord2d(((double)x+1.)/(gridData.numColumns-1.), ((double)(gridData.numRows-y))/(gridData.numRows-1.));
				gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{cellX+cellSizeX, cellY, unitsPerMeter*(gridData.height[y][x+1]-gridData.avgHeight)}));
			}
			gl2.glEnd();
		}
	}
	
	/**
	 * getVertexNormal determines the (normalized) normal vector for the given coordinates in the grid.  It calls
	 * getTriNormal for each of the surrounding faces, sums these normals, and normalizes the result. 
	 * @param x the x-coordinate of the point to get the normal for
	 * @param y the y-coordinate of the point to get the normal for
	 * @return an array of doubles, length 3, which represents the normal vector at that point
	 */
	private double[] getVertexNormal(int x, int y)
	{
		ArrayList<double[]> normalsToSum = new ArrayList<double[]>(); 
		if(x > 0)
		{
			double[] cellPos1 = cellToWorld(x-1,y);
			double[] cellPos2 = cellToWorld(x,y);
			if(y < gridData.numRows-1) //lower-left face
			{
				double[] cellPos3 = cellToWorld(x,y+1);
				normalsToSum.add(getTriNormal(new double[][]{{cellPos1[0], cellPos1[1], gridData.height[y][x-1]*unitsPerMeter},
														     {cellPos2[0], cellPos2[1], gridData.height[y][x]*unitsPerMeter},
														     {cellPos3[0], cellPos3[1], gridData.height[y+1][x]*unitsPerMeter}}));
			}
			if(y > 0) //upper-left faces
			{
				double[] cellPos3 = cellToWorld(x,y-1);
				double[] cellPos4 = cellToWorld(x-1,y-1);
				normalsToSum.add(getTriNormal(new double[][]{{cellPos2[0], cellPos2[1], gridData.height[y][x]*unitsPerMeter},
														     {cellPos1[0], cellPos1[1], gridData.height[y][x-1]*unitsPerMeter},
														     {cellPos4[0], cellPos4[1], gridData.height[y-1][x-1]*unitsPerMeter}}));
				normalsToSum.add(getTriNormal(new double[][]{{cellPos4[0], cellPos4[1], gridData.height[y-1][x-1]*unitsPerMeter},
														     {cellPos3[0], cellPos3[1], gridData.height[y-1][x]*unitsPerMeter},
														     {cellPos2[0], cellPos2[1], gridData.height[y][x]*unitsPerMeter}}));
			}
		}
		if(x < gridData.numColumns-1)
		{
			double[] cellPos1 = cellToWorld(x,y);
			double[] cellPos2 = cellToWorld(x+1,y);
			if(y < gridData.numRows-1) //lower-right faces
			{
				double[] cellPos3 = cellToWorld(x,y+1);
				double[] cellPos4 = cellToWorld(x+1,y+1);
				normalsToSum.add(getTriNormal(new double[][]{{cellPos1[0], cellPos1[1], gridData.height[y][x]*unitsPerMeter},
														     {cellPos4[0], cellPos4[1], gridData.height[y+1][x+1]*unitsPerMeter},
														     {cellPos3[0], cellPos3[1], gridData.height[y+1][x]*unitsPerMeter}}));
				normalsToSum.add(getTriNormal(new double[][]{{cellPos1[0], cellPos1[1], gridData.height[y][x]*unitsPerMeter},
														     {cellPos2[0], cellPos2[1], gridData.height[y][x+1]*unitsPerMeter},
														     {cellPos4[0], cellPos4[1], gridData.height[y+1][x+1]*unitsPerMeter}}));
			}
			if(y > 0) //upper-right face
			{
				double[] cellPos3 = cellToWorld(x,y-1);
				normalsToSum.add(getTriNormal(new double[][]{{cellPos1[0], cellPos1[1], gridData.height[y][x]*unitsPerMeter},
														     {cellPos3[0], cellPos3[1], gridData.height[y-1][x]*unitsPerMeter},
														     {cellPos2[0], cellPos2[1], gridData.height[y][x+1]*unitsPerMeter}}));
			}
		}
		
		//Sum and normalize to get the result.
		double[] result = new double[3];
		for(int i = 0; i < 3; i++) result[i] = 0;
		for(double[] n : normalsToSum)
		{
			result[0] += n[0];
			result[1] += n[1];
			result[2] += n[2];
		}
		double mag = magnitude(result);
		return vectorMultScalar(result,1./mag);
	}
	
	/**
	 * getTriNormal calculates the normal for a face.  Points should be specified in clockwise order.
	 * @param points the points to calculate the normal for
	 * @return normalized normal for the face
	 */
	private double[] getTriNormal(double[][] points)
	{
		if(points.length != 3 || points[0].length != 3) return null;
		double[] result =  crossProduct(new double[]{points[2][0]-points[0][0], points[2][1]-points[0][1], points[2][2]-points[0][2]},
										  new double[]{points[1][0]-points[0][0], points[1][1]-points[0][1], points[1][2]-points[0][2]});
		double mag = magnitude(result);
		return vectorMultScalar(result, 1./mag);
	}
	
	/**
	 * Calculates the highest point in the current mesh and draws the marker at it. It uses two offsets to
	 * determine which point in the image should be touch the high point.
	 */
	private void drawMarker()
	{
		double[] highPt = new double[3];
		highPt[0] = cellSizeX * gridData.maxHeightXIdx - gridWidth/2;
		highPt[1] = cellSizeY * (gridData.numRows-1-gridData.maxHeightYIdx) - gridHeight/2;
		highPt[2] = unitsPerMeter * (gridData.maxHeight-gridData.avgHeight);
		double sideLength = MARKER_SIDE_LENGTH*unitsPerMeter;
		
		double quadOffsetX = -0.1;
		double quadOffsetZ = 0.;
		
		double normLen = Math.sqrt(1./2.);
		
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_AMBIENT, FloatBuffer.wrap(markerAmbient));
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_DIFFUSE, FloatBuffer.wrap(markerDiffuse));
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_SPECULAR, FloatBuffer.wrap(markerSpecular));
		gl2.glMaterialf(GL2.GL_FRONT, GL2.GL_SHININESS, markerShininess);
		
		if(markerTexture != null)
		{
			markerTexture.enable(gl2);
			markerTexture.bind(gl2);
		}
		
		gl2.glEnable(GL2.GL_BLEND);
		gl2.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA);
		gl2.glBegin(GL.GL_TRIANGLE_STRIP);
		
		gl2.glNormal3d(-normLen, normLen, 0);
		gl2.glTexCoord2d(0.,1.);
		gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{highPt[0]+sideLength*quadOffsetX,
													   highPt[1],
													   highPt[2]+sideLength*(quadOffsetZ+1)}));
		gl2.glNormal3d(normLen, normLen, 0);
		gl2.glTexCoord2d(1.,1.);
		gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{highPt[0]+sideLength*(quadOffsetX+1),
													   highPt[1],
													   highPt[2]+sideLength*(quadOffsetZ+1)}));
		
		gl2.glNormal3d(-normLen, -normLen, 0);
		gl2.glTexCoord2d(0.,0.);
		gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{highPt[0]+sideLength*quadOffsetX,
													   highPt[1],
													   highPt[2]+sideLength*quadOffsetZ}));
		
		gl2.glNormal3d(normLen, -normLen, 0);
		gl2.glTexCoord2d(1.,0.);
		gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{highPt[0]+sideLength*(quadOffsetX+1),
													   highPt[1],
													   highPt[2]+sideLength*quadOffsetZ}));
		
		gl2.glEnd();
		gl2.glDisable(GL2.GL_BLEND);
	}
	
	/**
	 * Draws each of the currently existing projectiles.  It uses the current camera direction to
	 * make sure the projectiles are always facing the camera.  Since we're using gluLookAt, I don't
	 * have the matrix to perform this transformation on display lists, so we render them in immediate mode.
	 */
	private void drawProjectiles()
	{
		//Finally, draw each of the projectiles
		//Calculate half the length of the diagonal given the side length
		double hdLength = (Math.sqrt(2.*Math.pow(PROJECTILE_SIDE_LENGTH,2.))/2.)*unitsPerMeter;
		
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_AMBIENT, FloatBuffer.wrap(P_MAT_AMBIENT));
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_DIFFUSE, FloatBuffer.wrap(P_MAT_DIFFUSE));
		gl2.glMaterialfv(GL2.GL_FRONT, GL2.GL_SPECULAR, FloatBuffer.wrap(P_MAT_SPECULAR));
		gl2.glMaterialf(GL2.GL_FRONT, GL2.GL_SHININESS, P_MAT_SHININESS);
		
		if(projectileTexture != null)
		{
			projectileTexture.enable(gl2);
			projectileTexture.bind(gl2);
		}
		
		double[] camRight = crossProduct(camDir, camUp);
		double[] camRightDiagNormal = this.vectorAdd(camRight, camUp);
		double[] camLeftDiagNormal = this.vectorAdd(vectorMultScalar(camRight,-1), camUp);
		double crdnMag = magnitude(camRightDiagNormal); double cldnMag = magnitude(camLeftDiagNormal);
		camRightDiagNormal = this.vectorMultScalar(camRightDiagNormal, 1./crdnMag);
		camLeftDiagNormal = this.vectorMultScalar(camLeftDiagNormal, 1./cldnMag);
		
		gl2.glEnable(GL2.GL_BLEND);
		gl2.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA);
		for(double[] proj : projectiles)
		{
			gl2.glBegin(GL.GL_TRIANGLE_STRIP);
			
			gl2.glNormal3d(camLeftDiagNormal[0], camLeftDiagNormal[1], camLeftDiagNormal[2]);
			gl2.glTexCoord2d(0.,1.);
			gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{proj[0]+hdLength*camLeftDiagNormal[0],
														   proj[1]+hdLength*camLeftDiagNormal[1],
														   proj[2]+hdLength*camLeftDiagNormal[2]}));
			gl2.glNormal3d(camRightDiagNormal[0], camRightDiagNormal[1], camRightDiagNormal[2]);
			gl2.glTexCoord2d(1.,1.);
			gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{proj[0]+hdLength*camRightDiagNormal[0],
														   proj[1]+hdLength*camRightDiagNormal[1],
														   proj[2]+hdLength*camRightDiagNormal[2]}));
			gl2.glNormal3d(-camRightDiagNormal[0], -camRightDiagNormal[1], -camRightDiagNormal[2]);
			gl2.glTexCoord2d(0.,0.);
			gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{proj[0]-hdLength*camRightDiagNormal[0],
														   proj[1]-hdLength*camRightDiagNormal[1],
														   proj[2]-hdLength*camRightDiagNormal[2]}));
			gl2.glNormal3d(-camLeftDiagNormal[0], -camLeftDiagNormal[1], -camLeftDiagNormal[2]);
			gl2.glTexCoord2d(1.,0.);
			gl2.glVertex3dv(DoubleBuffer.wrap(new double[]{proj[0]-hdLength*camLeftDiagNormal[0],
														   proj[1]-hdLength*camLeftDiagNormal[1],
														   proj[2]-hdLength*camLeftDiagNormal[2]}));
			gl2.glEnd();
		}
		gl2.glDisable(GL2.GL_BLEND);
	}

	/**
	 * updateProjectiles iterates over the currently existing projectiles and moves them according to their speed.
	 * If they have expired or collided with the ground, they are deleted.  OpenGL lights are also enabled/disabled
	 * and moved according to the number of projectiles and their positions.
	 * 
	 * @param timePassed How much time has passed since the last update. Used to calculate projectile motion.
	 */
	private void updateProjectiles(double timePassed)
	{
		if(projectiles.isEmpty()) return;
		
		//Update projectile state
		for(int i = 0; i < projectiles.size(); i++)
		{
			projectiles.get(i)[0] += projectiles.get(i)[3]*timePassed;
			projectiles.get(i)[1] += projectiles.get(i)[4]*timePassed;
			projectiles.get(i)[2] += projectiles.get(i)[5]*timePassed;
			double height = getTerrainElevation(projectiles.get(i)[0],projectiles.get(i)[1]);
			if(height > projectiles.get(i)[2])
				projectiles.get(i)[6] = -1;
			else
				projectiles.get(i)[6] -= timePassed;
			gl2.glLightfv(GL2.GL_LIGHT1+i, GL2.GL_POSITION, FloatBuffer.wrap(new float[]{(float)projectiles.get(i)[0],
																						 (float)projectiles.get(i)[1],
																						 (float)projectiles.get(i)[2],
																						 1.0f}));			
		}
		Iterator<double[]> projIterator = projectiles.iterator();
		while(projIterator.hasNext())
		{
			double[] thisProj = projIterator.next();
			if(thisProj[6] <= 0) projIterator.remove();
		}
		
		//Turn OpenGL lights on or off according to how many flares are in play.
		while(projectiles.size() > numFlareLights)
		{
			gl2.glEnable(GL2.GL_LIGHT1 + numFlareLights);
			numFlareLights++;
		}
		while(projectiles.size() < numFlareLights)
		{
			gl2.glDisable(GL2.GL_LIGHT1 + numFlareLights-1);
			numFlareLights--;
		}
	}
	
	/**
	 * cellToWorld maps from the given cell coordinates to the corresponding coordinates in world space.
	 * 
	 * @param cellX the x-coordinate in cell-space
	 * @param cellY the y-coordinate in cell-space
	 * @return a length-2 array with the corresponding world-coordinates
	 */
	private double[] cellToWorld(double cellX, double cellY)
	{
		if(cellX < 0 || cellX > gridData.numColumns || cellY < 0 || cellY > gridData.numRows)
			return new double[]{-1,-1};
			
		return new double[]{cellX*gridData.cellSizeX*unitsPerMeter - gridWidth/2.,
							gridHeight/2. - cellY*gridData.cellSizeY*unitsPerMeter};
	}
	/**
	 * worldToCell maps from the given world coordinates to the corresponding coordinates in cell space.
	 * 
	 * @param cellX the x-coordinate in world-space
	 * @param cellY the y-coordinate in world-space
	 * @return a length-2 array with the corresponding cell-coordinates
	 */
	private double[] worldToCell(double worldX, double worldY)
	{
		if(worldX < -gridWidth/2. || worldX > gridWidth/2. || worldY < -gridHeight/2. || worldY > gridHeight/2.)
			return new double[]{-1,-1};
		
		return new double[]{(worldX+gridWidth/2.)/unitsPerMeter/gridData.cellSizeX,
							(gridHeight/2.-worldY)/unitsPerMeter/gridData.cellSizeY};
	}
	
	/**
	 * vectorAdd adds two vectors together and returns the results.
	 * @param v1 the first vector
	 * @param v2 the second vector
	 * @return the resulting vector
	 */
	private double[] vectorAdd(double[] v1, double[] v2)
	{
		if(v1.length != v2.length) return null;
		double[] v3 = v1.clone();
		for(int i = 0; i < v3.length; i++)
			v3[i] += v2[i];
		return v3;
	}
	
	/**
	 * vectorMultScalar multiplies a scalar by a vector and returns the results.
	 * @param v the vector
	 * @param s the scalar
	 * @return the resulting vector
	 */
	private double[] vectorMultScalar(double[] v, double s)
	{
		double[] vR = v.clone();
		for(int i = 0; i < vR.length; i++)
			vR[i] *= s;
		return vR;
	}
	
	/**
	 * matrixVectorMult multiplies a matrix by a vector with a length corresponding to the matrix's height
	 * and returns the results.
	 * @param m the matrix
	 * @param v the vector
	 * @return the resulting vector, in an array
	 */
	private double[] matrixVectorMult(double[][] m, double[] v)
	{
		for(int i = 0; i < m.length; i++)
			if(m[i].length != v.length) return null;
		
		double[] result = new double[m.length];
		for(int i = 0; i < m.length; i++)
		{
			result[i] = 0;
			for(int j = 0; j < v.length; j++)
			{
				result[i] += m[i][j]*v[j];
			}
		}
		return result;
	}
	
	/**
	 * matrixVectorMult multiplies two matrices together and returns the results.
	 * @param m the first matrix
	 * @param v the second matrix
	 * @return the resulting matrix, in a 2D array
	 */
	private double[][] matrixMult(double[][] m1, double[][] m2)
	{
		int m = m1.length; int n = m1[0].length; int p = m2[0].length;
		if(n != m2.length) return null;
		
		double[][] result = new double[m][p];
		for(int i = 0; i < m; i++)
		{
			for(int j = 0; j < p; j++)
			{
				result[i][j] = 0;
				for(int k = 0; k < m; k++)
				{
					result[i][j] += m1[i][k]*m2[k][j];
				}
			}
		}
		return result;
	}
	
	/**
	 * rotateX applies a rotation around the x-axis to a length-3 vector array.
	 * The fourth coordinate is assumed to be 0.
	 * @param theta the angle of rotation
	 * @param v the vector to rotate
	 * @return the resulting vector, in an array
	 */
	private double[] rotateX(double theta, double[] v)
	{
		if(v.length != 3) return null;
		return new double[]{v[0],
							v[1]*Math.cos(theta) - v[2]*Math.sin(theta),
							v[1]*Math.sin(theta) + v[2]*Math.cos(theta)};
	}
	
	/**
	 * rotateY applies a rotation around the y-axis to a length-3 vector array.
	 * The fourth coordinate is assumed to be 0.
	 * @param theta the angle of rotation
	 * @param v the vector to rotate
	 * @return the resulting vector, in an array
	 */
	private double[] rotateY(double theta, double[] v)
	{
		if(v.length != 3) return null;
		return new double[]{v[0]*Math.cos(theta) + v[2]*Math.sin(theta),
							v[1],
							-v[0]*Math.sin(theta) + v[2]*Math.cos(theta)};
	}
	
	/**
	 * rotateZ applies a rotation around the z-axis to a length-3 vector array.
	 * The fourth coordinate is assumed to be 0.
	 * @param theta the angle of rotation
	 * @param v the vector to rotate
	 * @return the resulting vector, in an array
	 */
	private double[] rotateZ(double theta, double[] v)
	{
		if(v.length != 3) return null;
		return new double[]{v[0]*Math.cos(theta) - v[1]*Math.sin(theta),
							v[0]*Math.sin(theta) + v[1]*Math.cos(theta),
							v[2]};
	}
	
	/**
	 * crossProduct finds the cross-product of two length-3 vectors and returns the result.
	 * @param v1 the first vector
	 * @param v2 the second vector
	 * @return the resulting vector, in an array
	 */
	private double[] crossProduct(double[] v1, double[] v2)
	{
		if(v1.length != 3 || v2.length != 3) return null;
		return new double[]{(v1[1]*v2[2]-v1[2]*v2[1]),
						   -(v1[0]*v2[2]-v1[2]*v2[0]),
						    (v1[0]*v2[1]-v1[1]*v2[0])};
	}
	
	/**
	 * Returns the magnitude of a vector array v of length 1 or more.
	 * @param v the vector
	 * @return the magnitude of v
	 */
	private double magnitude(double[] v)
	{
		double squareSum = 0;
		for(int i = 0; i < v.length; i++)
			squareSum += v[i]*v[i];
		return Math.sqrt(squareSum);
	}

	/**
	 * Finds the elevation of the terrain at a point xPos, yPos (world coordinates). It locates which
	 * triangle this lies inside and calculates the height based on the normal of that face.
	 * @param xPos the x-coordinate to get the elevation at
	 * @param yPos the y-coordinate to get the elevation at
	 * @return the z-coordinate at that point
	 */
	private double getTerrainElevation(double xPos, double yPos)
	{
		//Find cell
		double[] cellScalePos = worldToCell(xPos, yPos);
		if(cellScalePos[0] == -1 || cellScalePos[1] == -1) return -1;
		else if (cellScalePos[0] > gridData.numColumns-1 || cellScalePos[1] > gridData.numRows-1) return -1;
		
		int upperLeftX = (int)cellScalePos[0];
		int upperLeftY = (int)cellScalePos[1];
		double fractionalXDist = cellScalePos[0]-upperLeftX;
		double fractionalYDist = cellScalePos[1]-upperLeftY;

		double[] ul = new double[]{upperLeftX, upperLeftY, gridData.height[upperLeftY][upperLeftX]};
		double[] ur = new double[]{upperLeftX+1, upperLeftY, gridData.height[upperLeftY][upperLeftX+1]};
		double[] ll = new double[]{upperLeftX, upperLeftY+1, gridData.height[upperLeftY+1][upperLeftX]};
		double[] lr = new double[]{upperLeftX+1, upperLeftY+1, gridData.height[upperLeftY+1][upperLeftX+1]};

		double finalElevation = 0;
		
		//Note that the mesh is drawn with each cell having an
		//lower-left to upper-right diagonal (in cell-space).
		if(fractionalXDist < 1.-fractionalYDist)// in the upper-left tri
		{
			//Points are ul, ur, ll
			double[] v1 = new double[]{ll[0]-ul[0], ll[1]-ul[1], ll[2]-ul[2]};
			double[] v2 = new double[]{ur[0]-ul[0], ur[1]-ul[1], ur[2]-ul[2]};
			double[] normal = crossProduct(v1,v2);
			double normMag = magnitude(normal);
			normal = vectorMultScalar(normal, 1./normMag);
			finalElevation = ul[2]-((normal[0]*fractionalXDist) + (normal[1]*fractionalYDist))/normal[2];
		}
		else //lower-right tri
		{
			//Points are ll, ur, lr
			double[] v1 = new double[]{lr[0]-ll[0], lr[1]-ll[1], lr[2]-ll[2]};
			double[] v2 = new double[]{ur[0]-ll[0], ur[1]-ll[1], ur[2]-ll[2]};
			double[] normal = crossProduct(v2,v1);
			double normMag = magnitude(normal);
			normal = vectorMultScalar(normal, 1./normMag);
			finalElevation = ll[2]-((normal[0]*fractionalXDist) + (normal[1]*(fractionalYDist-1.)))/normal[2];
		}
		return unitsPerMeter*(finalElevation-gridData.avgHeight);
	}
	
	/**
	 * Get the user's current height, depending on whether the crouch button is held.
	 * @return the height in world-coordinates
	 */
	private double getUserHeight()
	{
		if(rMouseDown) return (unitsPerMeter*USER_CROUCH_HEIGHT);
		else return (unitsPerMeter*USER_HEIGHT);
	}
	
	/**
	 * Interpolates between two length-three arrays. percentStart of the first color is added to
	 * (1-percentStart) of the second color.
	 * @param startColor the color to start at
	 * @param destColor the color to end at
	 * @param percentStart weight of the first color
	 * @return the resulting color
	 */
	private float[] interpolateColors(float[] startColor, float[] destColor, double percentStart)
	{
		return new float[]{(float)(startColor[0]*percentStart+destColor[0]*(1.-percentStart)),
							(float)(startColor[1]*percentStart+destColor[1]*(1.-percentStart)),
							(float)(startColor[2]*percentStart+destColor[2]*(1.-percentStart))};
	}
	
	/**
	 * Interpolates between two length-four arrays. percentStart of the first light is added to
	 * (1-percentStart) of the second light.
	 * @param startLight the light to start at
	 * @param destLight the light to end at
	 * @param percentStart weight of the first light
	 * @return the resulting light
	 */
	private float[] interpolateLights(float[] startLight, float[] destLight, double percentStart)
	{
		return new float[]{(float)(startLight[0]*percentStart+destLight[0]*(1.-percentStart)),
							(float)(startLight[1]*percentStart+destLight[1]*(1.-percentStart)),
							(float)(startLight[2]*percentStart+destLight[2]*(1.-percentStart)),
							(float)(startLight[3]*percentStart+destLight[3]*(1.-percentStart))};
	}
	
	/**
	 * Updates the camera position, orientation, and perspective based on user input and the time that's passed.
	 * @param updateTime the time that has passed since the last update
	 */
	private void updateCameraState(double updateTime)
	{
		double forwardMovement = 0;
		double rightMovement = 0;
		double speed = (USER_WALK_SPEED*updateTime)*unitsPerMeter*speedMultiplier;
		if(wDown) forwardMovement += speed;
		if(sDown) forwardMovement -= speed;
		if(dDown) rightMovement += speed;
		if(aDown) rightMovement -= speed;
		
		//Get the projection of the direction in the x-y plane and normalize it.
		double camDirProjMag = Math.sqrt(camDir[0]*camDir[0]+camDir[1]*camDir[1]);
		double[] camDirProjN = new double[]{camDir[0]/camDirProjMag,camDir[1]/camDirProjMag,0};

		//Get the right vector, and get its projection as well.
		double[] camRight = crossProduct(camDirProjN, DEFAULT_UP);
		double camRightMag = magnitude(camRight);
		double[] camRightProjN = new double[]{camRight[0]/camRightMag,camRight[1]/camRightMag,0};
		
		if(!flyMode)
		{
			//Move the camera laterally.
			camPos = vectorAdd(camPos, vectorMultScalar(camDirProjN, forwardMovement));
			camPos = vectorAdd(camPos, vectorMultScalar(camRightProjN, rightMovement));
			
			//Determine the camera height.
			double groundHeight = getTerrainElevation(camPos[0],camPos[1]);
			if(groundHeight == -1)
				groundHeight = gridData.avgHeight*unitsPerMeter;

			if(jumping)
			{
				double prevVelocity = camVelocity;
				camVelocity -= WORLD_GRAVITY*unitsPerMeter*updateTime;
				camPos[2] += ((prevVelocity+camVelocity)/2.)*updateTime;

				if(camPos[2] < groundHeight)
				{
					jumping = false;
					camPos[2] = groundHeight;
					camVelocity = 0;
				}
			}
			else camPos[2] = groundHeight;
		}
		else
		{
			//Move the camera straight.
			double camDirMag = magnitude(camDir);
			camPos = vectorAdd(camPos, vectorMultScalar(camDir, forwardMovement/camDirMag));
			camPos = vectorAdd(camPos, vectorMultScalar(camRight, rightMovement/camRightMag));
		}
		
		if(spaceDown && !jumping)
		{
			jumping = true;
			spaceDown = false;
			camVelocity = Math.sqrt(2.*USER_JUMP_HEIGHT*WORLD_GRAVITY)*unitsPerMeter;
		}
		
		//Handle mouse input to apply camera rotation.
		double theta = -2.*(mouseY-canvasCenterY)/((double)canvasHeight)*ROTATION_RANGE_Y;
		if(camDirProjN[1] > 1) camDirProjN[1] = 1.; //To account for mathematical error
		else if(camDirProjN[1] < -1) camDirProjN[1] = -1.;
		double thetaY = Math.acos(camDirProjN[1]); //rotation to y axis.
		if(camDirProjN[0] < 0) thetaY = -thetaY;
		camDir = rotateZ(-thetaY,
	 			 rotateX(theta,
	 			 rotateZ(thetaY,
	 			 camDirProjN)));
		
		double phi = -2.*(mouseX-canvasCenterX)/((double)canvasWidth)*ROTATION_SPEED_X;
		camDir = rotateZ(phi, camDir);
		
		//Handle mouse wheel rolls to alter FOV.
		camFOV += wheelMoves*FOV_INCREMENT;
		if(camFOV < FOV_MIN) camFOV = FOV_MIN;
		else if (camFOV > FOV_MAX) camFOV = FOV_MAX;
		wheelMoves = 0;
		
		//Adjust the perspective according to changes and update the camera orientation.
		gl2.glMatrixMode(GL2.GL_PROJECTION);
		gl2.glLoadIdentity();
		double vertAngle = camFOV/camAspectRatio;
		glu.gluPerspective(vertAngle, camAspectRatio, camZNear, camZFar);
		gl2.glMatrixMode(GL2.GL_MODELVIEW);
		glu.gluLookAt(camPos[0], camPos[1], camPos[2]+getUserHeight(),
				  camPos[0]+camDir[0], camPos[1]+camDir[1], camPos[2]+camDir[2],
				  camUp[0], camUp[1], camUp[2]);
		gl2.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT);
	}
	
	/*
	 * updateLightPosition updates the orientation of the main scene light as well as the color
	 * of the scene background according to the simulation's internal time-of-day.  This time
	 * is affected by the time that's passed since the last light update. 
	 */
	private void updateLightPosition(double secsPassed)
	{
		timeOfDay = (timeOfDay + secsPassed*SECONDS_TO_HOURS*TIME_SPEED_MULTIPLIER)%TIME_HOURS_PER_DAY;
		double lightAnglePercent;
		
		if(timeOfDay >= TIME_SUNRISE_MID && timeOfDay < TIME_SUNSET_MID)
			lightAnglePercent = (TIME_SUNSET_MID-timeOfDay)/(TIME_SUNSET_MID-TIME_SUNRISE_MID);
		else
		{
			double tempTime = timeOfDay;
			double tempSunrise = TIME_SUNRISE_MID+TIME_HOURS_PER_DAY;
			if(timeOfDay < TIME_SUNSET_MID)
			{
				tempTime += TIME_HOURS_PER_DAY;
			}
			lightAnglePercent = (tempSunrise-tempTime)/(tempSunrise-TIME_SUNSET_MID);
		}
		double actualAngle = (1.-lightAnglePercent)*(LIGHT_END_ANGLE-LIGHT_START_ANGLE) + LIGHT_START_ANGLE;
		float[] lightPosition = new float[]{(float)Math.cos(actualAngle),0.0f,-(float)Math.sin(actualAngle),0.0f};

		gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, FloatBuffer.wrap(lightPosition));
		
		if(timeOfDay < TIME_SUNRISE_START || timeOfDay >= TIME_SUNSET_END)
		{
			backgroundColor = TIME_COLOR_NIGHT;
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, FloatBuffer.wrap(NIGHT_LIGHT_AMBIENT));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, FloatBuffer.wrap(NIGHT_LIGHT_DIFFUSE));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, FloatBuffer.wrap(NIGHT_LIGHT_SPECULAR));
		}
		else if(timeOfDay < TIME_SUNRISE_MID)
		{
			double percent = (TIME_SUNRISE_MID-timeOfDay)/(TIME_SUNRISE_MID-TIME_SUNRISE_START);
			backgroundColor = interpolateColors(TIME_COLOR_NIGHT, TIME_COLOR_SUNRISE, percent);
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, FloatBuffer.wrap(interpolateLights(NIGHT_LIGHT_AMBIENT, NO_LIGHT, percent)));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, FloatBuffer.wrap(interpolateLights(NIGHT_LIGHT_DIFFUSE, NO_LIGHT, percent)));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, FloatBuffer.wrap(interpolateLights(NIGHT_LIGHT_SPECULAR, NO_LIGHT, percent)));
		}
		else if(timeOfDay < TIME_SUNRISE_END)
		{
			double percent = (TIME_SUNRISE_END-timeOfDay)/(TIME_SUNRISE_END-TIME_SUNRISE_MID);
			backgroundColor = interpolateColors(TIME_COLOR_SUNRISE, TIME_COLOR_DAY, percent);
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, FloatBuffer.wrap(interpolateLights(NO_LIGHT, DAY_LIGHT_AMBIENT, percent)));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, FloatBuffer.wrap(interpolateLights(NO_LIGHT, DAY_LIGHT_DIFFUSE, percent)));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, FloatBuffer.wrap(interpolateLights(NO_LIGHT, DAY_LIGHT_SPECULAR, percent)));
		}
		else if (timeOfDay < TIME_SUNSET_START)
		{
			backgroundColor = TIME_COLOR_DAY;
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, FloatBuffer.wrap(DAY_LIGHT_AMBIENT));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, FloatBuffer.wrap(DAY_LIGHT_DIFFUSE));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, FloatBuffer.wrap(DAY_LIGHT_SPECULAR));
		}
		else if(timeOfDay < TIME_SUNSET_MID)
		{
			double percent = (TIME_SUNSET_MID-timeOfDay)/(TIME_SUNSET_MID-TIME_SUNSET_START);
			backgroundColor = interpolateColors(TIME_COLOR_DAY, TIME_COLOR_SUNSET, percent);
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, FloatBuffer.wrap(interpolateLights(DAY_LIGHT_AMBIENT, NO_LIGHT, percent)));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, FloatBuffer.wrap(interpolateLights(DAY_LIGHT_DIFFUSE, NO_LIGHT, percent)));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, FloatBuffer.wrap(interpolateLights(DAY_LIGHT_SPECULAR, NO_LIGHT, percent)));
		}
		else// if(timeOfDay < TIME_SUNRISE_END)
		{
			double percent = (TIME_SUNSET_END-timeOfDay)/(TIME_SUNSET_END-TIME_SUNSET_MID);
			backgroundColor = interpolateColors(TIME_COLOR_SUNSET, TIME_COLOR_NIGHT, percent);
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, FloatBuffer.wrap(interpolateLights(NO_LIGHT, NIGHT_LIGHT_AMBIENT, percent)));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, FloatBuffer.wrap(interpolateLights(NO_LIGHT, NIGHT_LIGHT_DIFFUSE, percent)));
			gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, FloatBuffer.wrap(interpolateLights(NO_LIGHT, NIGHT_LIGHT_SPECULAR, percent)));
		}
		gl2.glClearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], 0f); //set background color
	}
	
	//------------------------------------------------------------------------------
    // GLEventListener Implementation
    
	/**
	 * init is called when the program begins. It sets various OpenGL parameters, initializes
	 * the scene lights, and loads static textures.
	 */
	@Override
	public void init(GLAutoDrawable glautodrawable) {
		gl2 = glautodrawable.getGL().getGL2();
		glu = new GLU();
		
		gl2.glPointSize(10); //set up marker size/shape
        gl2.glEnable(GL2.GL_POINT_SMOOTH);
        gl2.glEnable(GL2.GL_DEPTH_TEST);
        gl2.glEnable(GL2.GL_TEXTURE_2D);
        
		//Generate display list numbers, and notify other parts of the program
		//that they've been generated.
		if(!listNumsGenerated)
		{
	        meshList = gl2.glGenLists(2);
	        markerList = meshList+1;
	        listNumsGenerated = true;
	        assert(meshList == 0); //glGenLists only returns 0 because of an error.
		}
		
		//Set up the light for the scene.
		gl2.glShadeModel(GL2.GL_SMOOTH);
		gl2.glEnable(GL2.GL_LIGHTING);
		gl2.glEnable(GL2.GL_LIGHT0);
		gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, FloatBuffer.wrap(DAY_LIGHT_AMBIENT));
		gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, FloatBuffer.wrap(DAY_LIGHT_DIFFUSE));
		gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, FloatBuffer.wrap(DAY_LIGHT_SPECULAR));
		gl2.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, FloatBuffer.wrap(INIT_LIGHT_POSITION));
		
		for(int i = 0; i < MAX_NUM_PROJECTILES; i++)
		{
			gl2.glLightfv(GL2.GL_LIGHT1+i, GL2.GL_AMBIENT, FloatBuffer.wrap(P_LIGHT_AMBIENT));
			gl2.glLightfv(GL2.GL_LIGHT1+i, GL2.GL_DIFFUSE, FloatBuffer.wrap(P_LIGHT_DIFFUSE));
			gl2.glLightfv(GL2.GL_LIGHT1+i, GL2.GL_SPECULAR, FloatBuffer.wrap(P_LIGHT_SPECULAR));
			gl2.glLightf(GL2.GL_LIGHT1+i, GL2.GL_CONSTANT_ATTENUATION, 1.0f);
			gl2.glLightf(GL2.GL_LIGHT1+i, GL2.GL_LINEAR_ATTENUATION, 1000.0f);
			gl2.glLightf(GL2.GL_LIGHT1+i, GL2.GL_QUADRATIC_ATTENUATION, 5.0f);
		}
		
		//Load in the textures that won't change with the terrain loaded.
		try {
			InputStream stream = new FileInputStream(MARKER_TEXTURE);
			TextureData data = TextureIO.newTextureData(myProfile, stream, false, "png");
			markerTexture = TextureIO.newTexture(data);
			stream.close();
			
			stream = new FileInputStream(PROJECTILE_TEXTURE);
			data = TextureIO.newTextureData(myProfile, stream, false, "png");
			projectileTexture = TextureIO.newTexture(data);
			stream.close();
		} catch (IOException e) {
			e.printStackTrace();
			markerTexture = null;
			projectileTexture = null;
		}
	}

	/**
	 * dispose is called when the context is closed. For now, nothing
	 * needs to be cleaned up.
	 */
	@Override
	public void dispose(GLAutoDrawable glautodrawable) {
	}

	/**
	 * display is called when the context is redrawn (at 60FPS here,
	 * because of the FPSAnimator). It houses update methods for
	 * the camera, lights, and, world objects, as well as drawing
	 * calls for everything that's displayed.
	 */
	@Override
	public void display(GLAutoDrawable glautodrawable) {
		//Only redraw when there's a loaded file.
		if(!currentDatafile.equals(""))
		{
			//Get our context
			gl2 = glautodrawable.getGL().getGL2();
			
			//Get the modelview matrix
			gl2.glMatrixMode(GL2.GL_MODELVIEW);
			gl2.glLoadIdentity();
			
			//Calculate time that's passed since the last update.
			long newTime = System.nanoTime();
			updateTime = ((double)(newTime-currentTime))*NS_TO_SECONDS; //convert to seconds
			currentTime = newTime;
			
			//Camera Setup
			updateCameraState(updateTime);
			//Update directional light for current camera orientation and time of day.
			updateLightPosition(updateTime);
			//Update projectile states and their lights.
			updateProjectiles(updateTime);
			
			//Generate display lists if need be.
			if(!meshGenerated)
			{
		        generateMeshes();
		        meshGenerated = true;
			}
			//Determine if the terrain should be drawn as wireframe.
			if(showWireframe)
				gl2.glPolygonMode( GL2.GL_FRONT_AND_BACK, GL2.GL_LINE );
			//Call the display lists.
			gl2.glCallList(meshList);
			//Return the renderer to normal.
			if(showWireframe)
				gl2.glPolygonMode( GL2.GL_FRONT_AND_BACK, GL2.GL_FILL );
			
			//Draw the highest-point marker if enabled.
			if(showMarker) gl2.glCallList(markerList);
			
			//Draw the projectiles.
			drawProjectiles();

			gl2.glFlush(); //Ensure that everything is performed.	
		}
	}

	/**
	 * Handle window reshape events by changing the viewport size. It also saves
	 * the window size and aspect ratio for mouse input and camera manipulation. 
	 */
	@Override
	public void reshape(GLAutoDrawable glautodrawable, int x, int y, int width,
			int height) {
    	//Get the context.
    	gl2 = glautodrawable.getGL().getGL2();
    	
    	//Set up projection for the new window.
    	canvasWidth = width;
    	canvasHeight = height;
    	canvasCenterX = width/2;
    	canvasCenterY = height/2;
    	camAspectRatio = ((double)width)/height;
		gl2.glViewport(0,0,width,height);
	}

	
	//------------------------------------------------------------------------------
    // MouseListener, MouseWheelListener Implementation

	@Override
	public void mouseClicked(MouseEvent arg0) {}
	@Override
	public void mouseEntered(MouseEvent e) {}
	@Override
	public void mouseExited(MouseEvent e) {}
	@Override
	public void mousePressed(MouseEvent e)
	{
		switch(e.getButton())
		{
			case MouseEvent.BUTTON1: 
				handleLeftClick();
				break;
			case MouseEvent.BUTTON3:
				rMouseDown = true;
				break;
		}
	}
	@Override
	public void mouseReleased(MouseEvent e)
	{
		switch(e.getButton())
		{
			case MouseEvent.BUTTON3:
				rMouseDown = false;
				break;
		}
	}
	@Override
	public void mouseMoved(MouseEvent e)
	{
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseDragged(MouseEvent e)
	{
		mouseX = e.getX();
		mouseY = e.getY();
	}
	
	@Override
	public void mouseWheelMoved(MouseWheelEvent event)
	{
		wheelMoves += event.getWheelRotation();
	}
	
	
	//------------------------------------------------------------------------------
    // Main Call
	
	/**
	 * The main method simply calls the constructor.
	 * @param args The String list of command line arguments. (None are used.)
	 */
	public static void main(String[] args)
	{
		new SceneWalkthrough();
	}
}
